<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-02-20T15:50:47.8524263"><title>hints | KaranocaVe's Blog</title><script type="application/json" id="virtual-toc-data">[]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/icon.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="hints | KaranocaVe's Blog"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="KaranocaVe's Blog Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="karanocave.infoconcept.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="hints | KaranocaVe's Blog"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "karanocave.infoconcept.html#webpage",
    "url": "karanocave.infoconcept.html",
    "name": "hints | KaranocaVe's Blog",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "karanocave.info/#website",
    "url": "karanocave.info/",
    "name": "KaranocaVe's Blog Help"
}</script><!-- End Schema.org --></head><body data-id="concept" data-main-title="hints" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="worldview.md|世界观///The-C-Programing-Language.md|The C Programing Language"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>KaranocaVe's Blog  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="concept" id="concept.md">hints</h1><ul class="list _ul" id="6a741d9e_198"><li class="list__item" id="6a741d9e_199"><p>表达式</p></li><li class="list__item" id="6a741d9e_200"><p>语句</p></li><li class="list__item" id="6a741d9e_201"><p>序列点</p></li><li class="list__item" id="6a741d9e_202"><p>左值</p></li><li class="list__item" id="6a741d9e_203"><p>字面量</p></li><li class="list__item" id="6a741d9e_204"><p>复合字面量</p></li><li class="list__item" id="6a741d9e_205"><p>块</p></li><li class="list__item" id="6a741d9e_206"><p>作用域</p></li><li class="list__item" id="6a741d9e_207"><p>基类型</p></li><li class="list__item" id="6a741d9e_208"><p>偏移</p></li><li class="list__item" id="6a741d9e_209"><p>伸缩型数组成员</p></li><li class="list__item" id="6a741d9e_210"><p>struct hack柔性数组成员</p></li><li class="list__item" id="6a741d9e_211"><p>嵌套的匿名成员结构</p></li><li class="list__item" id="6a741d9e_212"><p>嵌套联合</p></li><li class="list__item" id="6a741d9e_213"><p>记录</p></li><li class="list__item" id="6a741d9e_214"><p>字段</p></li><li class="list__item" id="6a741d9e_215"><p>链式结构</p></li><li class="list__item" id="6a741d9e_216"><p>标记名</p></li><li class="list__item" id="6a741d9e_217"><p>类型名</p></li><li class="list__item" id="6a741d9e_218"><p>名称空间</p></li><li class="list__item" id="6a741d9e_219"><p>char (* flump[3])(int);</p></li><li class="list__item" id="6a741d9e_220"><p>加了typedef，变量名就变成类型名</p></li><li class="list__item" id="6a741d9e_221"><p>从一个9 位组合100000000 （256 的二进制形式）减去一个负数的位组合，结果是该负值的量</p></li><li class="list__item" id="6a741d9e_222"><p>使用| 运算符，任何位与 0 组合，结果都为本身</p></li><li class="list__item" id="6a741d9e_223"><p>使用＆，任何位与 1 组合都得本身</p></li><li class="list__item" id="6a741d9e_224"><p>异或只知道同与不同</p></li><li class="list__item" id="6a741d9e_225"><p>预处理器只会替换</p></li><li class="list__item" id="6a741d9e_226"><p>记号型字符串 字符型字符串</p></li><li class="list__item" id="6a741d9e_227"><p>宏名称和替换体</p></li><li class="list__item" id="6a741d9e_228"><p>宏形参</p></li><li class="list__item" id="6a741d9e_229"><p>字符串化</p></li><li class="list__item" id="6a741d9e_230"><p>记号</p></li><li class="list__item" id="6a741d9e_231"><p>#组合 ##粘合</p></li><li class="list__item" id="6a741d9e_232"><p>变参宏</p></li><li class="list__item" id="6a741d9e_233"><p><code class="code" id="6a741d9e_234">__VA_ARGS__</code></p></li><li class="list__item" id="6a741d9e_235"><p>&quot;声明&quot;（Declaration）和&quot;指令&quot;（Statement）</p></li><li class="list__item" id="6a741d9e_236"><p>条件编译</p></li><li class="list__item" id="6a741d9e_237"><p>预定义标识符</p></li><li class="list__item" id="6a741d9e_238"><p>预定义宏</p></li><li class="list__item" id="6a741d9e_239"><p>泛型编程</p></li><li class="list__item" id="6a741d9e_240"><p>泛型选择表达式</p></li><li class="list__item" id="6a741d9e_241"><p>内联函数</p></li><li class="list__item" id="6a741d9e_242"><p>宏展开</p></li><li class="list__item" id="6a741d9e_243"><p>y = (sqrt) (x);</p></li><li class="list__item" id="6a741d9e_244"><p>assert() _Static_assert()</p></li><li class="list__item" id="6a741d9e_245"><p>变参宏</p></li><li class="list__item" id="6a741d9e_246"><p>可变参函数</p></li><li class="list__item" id="6a741d9e_247"><p>parmN</p></li><li class="list__item" id="6a741d9e_248"><p>找出正确的数据表示不仅仅是选择一种数据类型，还耍考虑必须进行哪些操作</p></li><li class="list__item" id="6a741d9e_249"><p>在C语言中，可以把所需要的操作设计成C函数来表示</p></li><li class="list__item" id="6a741d9e_250"><p>算法( algorithm ) ，即操控数据的方法</p></li><li class="list__item" id="6a741d9e_251"><p>设计数据类型的过程， 这是一个将算法和数据表示相匹配的过程</p></li><li class="list__item" id="6a741d9e_252"><p>抽象数据类型以面向问题而不是面向语言的方式，把解决问题的方法和数据表示结合起来</p></li><li class="list__item" id="6a741d9e_253"><p>在开始编写代码之前，需要做很多程序设计方面的决定</p></li><li class="list__item" id="6a741d9e_254"><p>头指针</p></li><li class="list__item" id="6a741d9e_255"><p>类型特指两类信息：属性和操作</p></li><li class="list__item" id="6a741d9e_256"><p>可以认为数学家提供了整数的抽象概念，而C则实现了这一抽象概念</p></li><li class="list__item" id="6a741d9e_257"><p>例如在C中，可以提供结构定义和操控该结构的函数原型，这些作用于用户定义类型的函数相当于作用于C基本类型的内置运算符</p></li><li class="list__item" id="6a741d9e_258"><p>链表是一个能储存一系列项且可以对其进行所需操作的数据对象。</p></li><li class="list__item" id="6a741d9e_259"><p>抽象数据类型（Abstract Data Type） ADT</p></li><li class="list__item" id="6a741d9e_260"><p>接口设计应尽量与ADT的描述保持一致</p></li><li class="list__item" id="6a741d9e_261"><p>节点(node)</p></li><li class="list__item" id="6a741d9e_262"><p>数据隐藏，是一种从编程的更高层次隐藏数据表示细节的艺术</p></li><li class="list__item" id="6a741d9e_263"><p>后置条件 postcondition</p></li><li class="list__item" id="6a741d9e_264"><p>C语言把所有类型和函数的信息集合成一个软件包的方法是：把类型定义和函数原型（包括前提条件和后置条件注释）放在一个头文件中。该文件应该提供程序员使用该类型所需的所有信息。</p></li><li class="list__item" id="6a741d9e_265"><p>在头文件中，把组成函数名的每个单词的首字母大写，以这种方式表明这些函数是接口包的一部分。</p></li><li class="list__item" id="6a741d9e_266"><p>list.h （定义数据结构和提供用户接口的原型）、list.c （提供函数代码实现接口）、films3.c （把链表接口应用于特定编程问题的源代码文件）</p></li><li class="list__item" id="6a741d9e_267"><p>ADT版本可读性更高，而且针对的是最终的用户所关心的问题。</p></li><li class="list__item" id="6a741d9e_268"><p>对大型编程项目而言，这种把实现和最终接口隔离的做法相当有用。这称为数据隐藏，因为对终端用户隐藏了数据表示的细节。</p></li><li class="list__item" id="6a741d9e_269"><p>队列是一种&quot;先进先出&quot;(first in, first out, 缩写为FIFO)的数据形式</p></li><li class="list__item" id="6a741d9e_270"><p>对链表而言，其大小受限于可用的内存量，因此链表不要太大。(really?)</p></li><li class="list__item" id="6a741d9e_271"><p>enqueue(enfiler)</p></li><li class="list__item" id="6a741d9e_272"><p>链接</p></li><li class="list__item" id="6a741d9e_273"><p>Front/Rear</p></li><li class="list__item" id="6a741d9e_274"><p>在重要程序中使用一个新的设计（如，队列包）之前，应该先测试该设计。</p></li><li class="list__item" id="6a741d9e_275"><p>驱动程序(driver)，其唯一的用途是进行测试</p></li><li class="list__item" id="6a741d9e_276"><p>用队列进行模拟</p></li><li class="list__item" id="6a741d9e_277"><p>在数组中插入元素，必须移动其他元素腾出空位插入新元素</p></li><li class="list__item" id="6a741d9e_278"><p>通过在创建节点时就设置好下一个指针(NULL)，可以简化插入操作的逻辑</p></li><li class="list__item" id="6a741d9e_279"><p>随机访问( random access ) | 顺序访问( sequential access )</p></li><li class="list__item" id="6a741d9e_280"><p>顺序查找( sequential search )</p></li><li class="list__item" id="6a741d9e_281"><p>使用并发编程，同时查找列表中的不同部分</p></li><li class="list__item" id="6a741d9e_282"><p>二分查找( binary search )， n 次比较能处理有 2n-1 个元素的数组，所以项数越多，越能体现二分查找的优势。</p></li><li class="list__item" id="6a741d9e_283"><p>目标项</p></li><li class="list__item" id="6a741d9e_284"><p>二叉查找树是－种结合了二分查找策略的链接结构。</p></li><li class="list__item" id="6a741d9e_285"><p>根（root）</p></li><li class="list__item" id="6a741d9e_286"><p>子树（subtree）</p></li><li class="list__item" id="6a741d9e_287"><p>叶节点（leaf）</p></li><li class="list__item" id="6a741d9e_288"><p>这种分支特性很适合使用分而制之的递归来处理</p></li><li class="list__item" id="6a741d9e_289"><p>二叉查找树只有在满员（或平衡）时效率最高</p></li><li class="list__item" id="6a741d9e_290"><p>AVL树</p></li><li class="list__item" id="6a741d9e_291"><p>因为要重构，所以创建一个平衡的树所花费的时间更多，但是这样的树可以确保最大化搜索效率。</p></li><li class="list__item" id="6a741d9e_292"><p>C已经涵盖了从简单的char类型变量到大型且复杂的结构在内的数据对象。面向对象语言更进一步发展了对象的观点。</p></li><li class="list__item" id="6a741d9e_293"><p>对象的性质不仅包括它所储存的信息类型，而且还包括了对其进行的操作类型。</p></li><li class="list__item" id="6a741d9e_294"><p>栈是一种LIFO （ 即后进先出last in,first out ) 结构。</p></li></ul><div class="last-modified">Last modified: 20 二月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="cessential.html" class="navigation-links__prev">&#36895;&#26597;&#34920;</a><a href="thecpuzzlebook.html" class="navigation-links__next">《C语言解惑》批注</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>