<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-02-03T13:26:48.9497738"><title>hints | KaranocaVe's Blog</title><script type="application/json" id="virtual-toc-data">[]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/icon.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="hints | KaranocaVe's Blog"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="KaranocaVe's Blog Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="karanocave.infohints.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="hints | KaranocaVe's Blog"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "karanocave.infohints.html#webpage",
    "url": "karanocave.infohints.html",
    "name": "hints | KaranocaVe's Blog",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "karanocave.info/#website",
    "url": "karanocave.info/",
    "name": "KaranocaVe's Blog Help"
}</script><!-- End Schema.org --></head><body data-id="hints" data-main-title="hints" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="worldview.md|世界观///The-Cpp-Programing-Language.md|The C++ Programing Language"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>KaranocaVe's Blog  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="hints" id="hints.md">hints</h1><ul class="list _ul" id="dfcfc7a_2372"><li class="list__item" id="dfcfc7a_2373"><p>宽度</p></li><li class="list__item" id="dfcfc7a_2374"><p>初始化器</p></li><li class="list__item" id="dfcfc7a_2375"><p>自然长度</p></li><li class="list__item" id="dfcfc7a_2376"><p>源字符集 执行字符集</p></li><li class="list__item" id="dfcfc7a_2377"><p>通用字符名</p></li><li class="list__item" id="dfcfc7a_2378"><p>算术类型</p></li><li class="list__item" id="dfcfc7a_2379"><p>任何值或任何有效的值和运算符的组合都是表达式</p></li><li class="list__item" id="dfcfc7a_2380"><p>＜＜运算符的优先级比表达式中使用的运算符高</p></li><li class="list__item" id="dfcfc7a_2381"><p>声明语句表达式(declaration-statement expression)</p></li><li class="list__item" id="dfcfc7a_2382"><p>for-init-statement</p></li><li class="list__item" id="dfcfc7a_2383"><p>顺序</p></li><li class="list__item" id="dfcfc7a_2384"><p>C+＋确保程序从左向右进行计算逻辑表达式，并在知道答案后立刻停止</p></li><li class="list__item" id="dfcfc7a_2385"><p>静态类型检查</p></li><li class="list__item" id="dfcfc7a_2386"><p>仅当只有一层间接关系时，才可以将非const地址或指针赋给const指针</p></li><li class="list__item" id="dfcfc7a_2387"><p>容忍逻辑上无法自圆其说的观点正是人类思维活动的特点</p></li><li class="list__item" id="dfcfc7a_2388"><p>自动推断只能用于单值初始化，不能用于初始化列表</p></li><li class="list__item" id="dfcfc7a_2389"><p>引用更接近const指针</p></li><li class="list__item" id="dfcfc7a_2390"><p>常量引用</p></li><li class="list__item" id="dfcfc7a_2391"><p>零时变量会使函数在可处理的参数种类方面更加通用，其行为类似按值传递</p></li><li class="list__item" id="dfcfc7a_2392"><p>将引用参数声明为常量数据的引用理由有三个:使用const可以避免无意中修改数据; 使函数可以处理const和非const实参;使函数可以正确生成使用临时变量。</p></li><li class="list__item" id="dfcfc7a_2393"><p>右值引用</p></li><li class="list__item" id="dfcfc7a_2394"><p>模糊特性增加了犯错的机会</p></li><li class="list__item" id="dfcfc7a_2395"><p>内置数据类型用指针，类用引用</p></li><li class="list__item" id="dfcfc7a_2396"><p>C强调速度，CPP强调稳定性</p></li><li class="list__item" id="dfcfc7a_2397"><p>&ldquo;多态&rdquo;指有多种形式</p></li><li class="list__item" id="dfcfc7a_2398"><p>模板特性有时也被称为参数化类型</p></li><li class="list__item" id="dfcfc7a_2399"><p>编译器在选择原型时，非模板版本优先于显式具体化，显式具体化优先于模板版本</p></li><li class="list__item" id="dfcfc7a_2400"><p>函数模板只是一个用于生成函数定义的方案</p></li><li class="list__item" id="dfcfc7a_2401"><p>模板并非函数定义，模板实例是函数定义</p></li><li class="list__item" id="dfcfc7a_2402"><p>隐式实例化、显式实例化、显式具体化统称为具体化</p></li><li class="list__item" id="dfcfc7a_2403"><p>显式实例化遇到引用可能会出问题</p></li><li class="list__item" id="dfcfc7a_2404"><p>重载解析</p></li><li class="list__item" id="dfcfc7a_2405"><p>最具体并不意味着显式具体化</p></li><li class="list__item" id="dfcfc7a_2406"><p>&ldquo;最具体&rdquo;</p></li><li class="list__item" id="dfcfc7a_2407"><p>C11后置返回类型</p></li><li class="list__item" id="dfcfc7a_2408"><p>存储持续性，作用域和链接</p></li><li class="list__item" id="dfcfc7a_2409"><p>头文件：包含结构声明和使用这些结构的函数原型</p></li><li class="list__item" id="dfcfc7a_2410"><p>源代码文件：包含与结构相关的函数的代码</p></li><li class="list__item" id="dfcfc7a_2411"><p>源代码文件：包含调用与结构相关的函数的代码</p></li><li class="list__item" id="dfcfc7a_2412"><p>翻译单元</p></li><li class="list__item" id="dfcfc7a_2413"><p>自动存储持续性（auto/register）</p></li><li class="list__item" id="dfcfc7a_2414"><p>静态存储持续性（static/全局）</p></li><li class="list__item" id="dfcfc7a_2415"><p>线程存储持续性（C++11）</p></li><li class="list__item" id="dfcfc7a_2416"><p>动态存储持续性（堆）</p></li><li class="list__item" id="dfcfc7a_2417"><p>链接性决定了哪些信息可在文件间共享</p></li><li class="list__item" id="dfcfc7a_2418"><figure id="dfcfc7a_2419"><img alt="stack" src="images/stack.png" title="stack" width="1018" height="1212"></figure></li><li class="list__item" id="dfcfc7a_2420"><p>静态变量都先执行零初始化后覆盖</p></li><li class="list__item" id="dfcfc7a_2421"><p>关键字重载</p></li><li class="list__item" id="dfcfc7a_2422"><p>存储说明符/cv-限定符</p></li><li class="list__item" id="dfcfc7a_2423"><p>通常编译器使用三块独立的内存：一块用于静态变量，一块用于自动变量，一块用于动态存储</p></li><li class="list__item" id="dfcfc7a_2424"><p>您可能想知道定位new 运算符的工作原理。基本上，它只是返回传递给它的地址，并将其强制转换 为void* ，以便能够赋给任何指针类型。但这说的是默认定位new 函数， C++允许程序员重载定位new函数</p></li><li class="list__item" id="dfcfc7a_2425"><p>名称可以是变量、函数、结构、枚举、类以及类和结构的成员</p></li><li class="list__item" id="dfcfc7a_2426"><p>声明区域(declaration region)</p></li><li class="list__item" id="dfcfc7a_2427"><p>潜在作用域(potential scope )</p></li><li class="list__item" id="dfcfc7a_2428"><figure id="dfcfc7a_2429"><img alt="作用域.png" src="images/%E4%BD%9C%E7%94%A8%E5%9F%9F.png" title="作用域.png" width="1075" height="2144"></figure></li><li class="list__item" id="dfcfc7a_2430"><p>在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。</p></li><li class="list__item" id="dfcfc7a_2431"><p>全局名称空间(global namespace)</p></li><li class="list__item" id="dfcfc7a_2432"><figure id="dfcfc7a_2433"><img alt="namespace.png" src="images/namespace.png" title="namespace.png" width="1971" height="831"></figure></li><li class="list__item" id="dfcfc7a_2434"><p>生活中充满复杂性，处理复杂性的方法之一是简化和抽象</p></li><li class="list__item" id="dfcfc7a_2435"><p>在C丑中，用户定义类型指的是实现抽象接口的类设计</p></li><li class="list__item" id="dfcfc7a_2436"><p>数据隐藏不仅可以防止直接访问数据，还让开发者（类的用户）无需了解数据是如何被表示的</p></li><li class="list__item" id="dfcfc7a_2437"><p>使用私有成员函数来处理不属于公有接 口的实现细节</p></li><li class="list__item" id="dfcfc7a_2438"><p>定义位于类声明中的函数都将自动成为内联函数</p></li><li class="list__item" id="dfcfc7a_2439"><p>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义</p></li><li class="list__item" id="dfcfc7a_2440"><p>根据改写规则(rewrite rule ) ，在类声明中定义方法等同于用原型替换方法定义，然后在类声明的后面将定义改写为内联函数</p></li><li class="list__item" id="dfcfc7a_2441"><p>隐式地调用默认构造函数时，不要使用圆括号</p></li><li class="list__item" id="dfcfc7a_2442"><p>默认构造函数可以没有任何参数；如果有，则必须给所有参数都提供默认值</p></li><li class="list__item" id="dfcfc7a_2443"><p>第一条语句是初始化，它创建有指定值的对象，可能会创建临时对象（也可能不会）；第二条语句是赋值。像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象。</p></li><li class="list__item" id="dfcfc7a_2444"><p>初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有默认构造函数。</p></li><li class="list__item" id="dfcfc7a_2445"><p>作用域内枚举（C++11）</p></li><li class="list__item" id="dfcfc7a_2446"><p>ADT 以通用的方式描述数据类型，而没有引入语言或实现细节</p></li><li class="list__item" id="dfcfc7a_2447"><p>只有类声明可以决定哪一个函数是友元，因此类声明仍然控制了哪些函数可以访问私有数据</p></li><li class="list__item" id="dfcfc7a_2448"><p>状态成员(state member)</p></li><li class="list__item" id="dfcfc7a_2449"><p>如果方法通过计算得到一个新的类对象，则应考虑是否可以使用类构造函数来完成这种工作。 这样做不仅可以避免麻烦，而且可以确保新的对象是按照正确的方式创建的</p></li><li class="list__item" id="dfcfc7a_2450"><p>将接口与实现分离是OOP 的目标之一，这样允许对实现进行调整，而无需修改使用这个类的程序中的代码</p></li><li class="list__item" id="dfcfc7a_2451"><p>因为所有的Vector 类方法的作用域都为整个类，所以导入类名后，无需提供其他using 声明，就可以使用Vector 的方法。</p></li><li class="list__item" id="dfcfc7a_2452"><p>只接受一个参数的构造函数定义了从参数类型到类类型的转换。如果使用关键字explicit 限定了这种构造函数， 则它只能用于显示转换， 否则也可以用于隐式转换。</p></li><li class="list__item" id="dfcfc7a_2453"><p>友元函数与成员函数之间的区别是什么？</p></li><li class="list__item" id="dfcfc7a_2454"><p>不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。</p></li><li class="list__item" id="dfcfc7a_2455"><p>对于不能在类声明中初始化静态数据成员的一种例外情况是，静态数据成员为整型或枚举型const</p></li><li class="list__item" id="dfcfc7a_2456"><p>按值传递意味着创建原始变量的一个副本</p></li><li class="list__item" id="dfcfc7a_2457"><p>默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值</p></li><li class="list__item" id="dfcfc7a_2458"><p>如果类中包含了使用new 初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。复制的另一种形式（ 成员复制或浅复制）只是复制指针值。浅复制仅浅浅地复制指针信息，而不会深入＂挖掘&ldquo;以复制指针引用的结构。</p></li><li class="list__item" id="dfcfc7a_2459"><p>初始化总是会调用复制构造函数，而使用式运算符时也可能调用赋值运算符</p></li><li class="list__item" id="dfcfc7a_2460"><p>赋值运算符有两个责任：妥善删除旧的数据、赋得新的数据，另外还要注意把自己赋给自己</p></li><li class="list__item" id="dfcfc7a_2461"><figure id="dfcfc7a_2462"><img alt="new.png" src="images/new.png" title="new.png" width="1738" height="660"></figure></li><li class="list__item" id="dfcfc7a_2463"><p>空指针本身的内部表示可能不是零</p></li><li class="list__item" id="dfcfc7a_2464"><p>首先，不能通过对象调用静态成员函数； 实际上，静态成员函数甚至不能使用this 指针。其次，由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。可以使用静态成员函数设置类级( classwide) 标记，以控制某些类接口的行为。</p></li><li class="list__item" id="dfcfc7a_2465"><p>使用const 引用的常见原因是旨在提高效率</p></li><li class="list__item" id="dfcfc7a_2466"><figure id="dfcfc7a_2467"><img alt="newobj.png" src="images/newobj.png" title="newobj.png" width="1174" height="1020"></figure></li><li class="list__item" id="dfcfc7a_2468"><p>显式地调用析构函数时，必须指定要销毁的对象</p></li><li class="list__item" id="dfcfc7a_2469"><p>对于使用定位new 运算符创建的对象， 应以与创建顺序相反的顺序进行删除。原因在于，晚创建的对象可能依赖于早创建的对象。另外，仅当所有对象都被销毁后，才能释放用于存储这些对象的缓冲区</p></li><li class="list__item" id="dfcfc7a_2470"><p>构造函数中要么使用new [], 要么使用new, 而不能混用。如果构造函数使用的是new[］，则析构函数应使用delete []; 如果构造函数使用的是new, 则析构函数应使用delete</p></li><li class="list__item" id="dfcfc7a_2471"><p>在类声明中声明的结构、类或枚举被称为是被嵌套在类中，其作用域为整个类。这种声明不会创建数据对象，而只是指定了可以在类中使用的类型。如果声明是在类的私有部分进行的，则只能在这个类使用被声明的类型；如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类型</p></li><li class="list__item" id="dfcfc7a_2472"><p>C++允许在类中包含结构、类和枚举定义。这些嵌套类型的作用域为整个类，这意味着它们被局限于类中， 不会与其他地方定义的同名结构、类和枚举发生冲突。</p></li><li class="list__item" id="dfcfc7a_2473"><p>成员初始化列表( member initializer list)</p></li><li class="list__item" id="dfcfc7a_2474"><p>只有构造函数可以使用这种初始化列表语法。对于const 类成员，必须使用这种语法。另外，对于被声明为引用的类成员，也必须使用这种语法</p></li><li class="list__item" id="dfcfc7a_2475"><p>使用成员初始化列表的构造函数将覆盖相应的类内初始化</p></li><li class="list__item" id="dfcfc7a_2476"><p>数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关</p></li><li class="list__item" id="dfcfc7a_2477"><p>复制构造函数还被用于创建其他的临时对象</p></li><li class="list__item" id="dfcfc7a_2478"><p>面向对象编程的主要目的之一是提供可重用的代码。开发新项目，尤其是当项目十分庞大时，重用经过测试的代码比重新编写代码要好得多。使用已有的代码可以节省时间，由于已有的代码已被使用和测试过，因此有助千避免在程序中引入错误。另外，必须考虑的细节越少，便越能专注于程序的整体策略。</p></li><li class="list__item" id="dfcfc7a_2479"><p>通常，类库是以源代码的方式提供的，这意味着可以对其进行修改，以满足需求。然而，C++提供了比修改代码更好的方法来扩展和修改类。这种方法叫作类继承，它能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。</p></li><li class="list__item" id="dfcfc7a_2480"><p>公有继承是最常用的方式，它建立一种is-a 关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。因为 派生类可以添加特性，所以，将这种关系称为is-a-kind-of （是一种）关系可能更准确，但是通常使用术语is-a 。公有继承不能建立is-like-a 关系， 也就是说，它不采用明喻。公有继承不能建立is-like-a 关系， 也就是说，它不采用明喻。继承可以在基类的基础上添加属性，但不能删除基类的属性。在有些情况下，可以设计一个包含共有特征的类，然后以is-a 或has-a关系， 在这个类的基础上定义相关的类。</p></li><li class="list__item" id="dfcfc7a_2481"><p>公有继承不建立is-implemented-as-a关系</p></li><li class="list__item" id="dfcfc7a_2482"><p>如果没有使用关键字virtual, 程序将根据引用类型或指针类型选择方法；如果使用了virtual,程序将根据引用或指针指向的对象的类型来选择方法。</p></li><li class="list__item" id="dfcfc7a_2483"><p>方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。然而，在派生类声明中使用关键字virtual 来指出哪些函数是虚函数也不失为一个好办法。</p></li><li class="list__item" id="dfcfc7a_2484"><p>在派生类方法中，标准技术是使用作用域解析运算符来调用基类方法</p></li><li class="list__item" id="dfcfc7a_2485"><p>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)</p></li><li class="list__item" id="dfcfc7a_2486"><p>在编译过程中进行联编被称为静态联编( static binding ) ， 又称为早期联编( early binding )</p></li><li class="list__item" id="dfcfc7a_2487"><p>编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编( dynamic binding ) ， 又称为晚期联编( late binding )</p></li><li class="list__item" id="dfcfc7a_2488"><p>将派生类引用或指针转换为基类引用或指针被称为向上强制转换(upcasting) ，这使公有继承不需要进行显式类型转换。该规则是is-a 关系的一部分</p></li><li class="list__item" id="dfcfc7a_2489"><p>相反的过程将基类指针或引用转换为派生类指针或引用称为向下强制转换(downcasting) 。如果不使用显式类型转换， 则向下强制转换是不允许的</p></li><li class="list__item" id="dfcfc7a_2490"><p>隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求</p></li><li class="list__item" id="dfcfc7a_2491"><p>编译器对非虚方法使用静态联编,对虚方法使用动态联编</p></li></ul><div class="last-modified">Last modified: 03 二月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="速查表.html" class="navigation-links__prev">速查表</a><a href="the-philosophy.html" class="navigation-links__next">The Philosophy</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>