<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-01-29T15:11:19.6132131"><title>hints | KaranocaVe's Blog</title><script type="application/json" id="virtual-toc-data">[]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/icon.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="hints | KaranocaVe's Blog"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="KaranocaVe's Blog Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="karanocave.infohints.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="hints | KaranocaVe's Blog"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "karanocave.infohints.html#webpage",
    "url": "karanocave.infohints.html",
    "name": "hints | KaranocaVe's Blog",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "karanocave.info/#website",
    "url": "karanocave.info/",
    "name": "KaranocaVe's Blog Help"
}</script><!-- End Schema.org --></head><body data-id="hints" data-main-title="hints" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="worldview.md|世界观///The-Cpp-Programing-Language.md|The C++ Programing Language"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>KaranocaVe's Blog  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="hints" id="hints.md">hints</h1><ul class="list _ul" id="459424c6_2231"><li class="list__item" id="459424c6_2232"><p>宽度</p></li><li class="list__item" id="459424c6_2233"><p>初始化器</p></li><li class="list__item" id="459424c6_2234"><p>自然长度</p></li><li class="list__item" id="459424c6_2235"><p>源字符集 执行字符集</p></li><li class="list__item" id="459424c6_2236"><p>通用字符名</p></li><li class="list__item" id="459424c6_2237"><p>算术类型</p></li><li class="list__item" id="459424c6_2238"><p>任何值或任何有效的值和运算符的组合都是表达式</p></li><li class="list__item" id="459424c6_2239"><p>＜＜运算符的优先级比表达式中使用的运算符高</p></li><li class="list__item" id="459424c6_2240"><p>声明语句表达式(declaration-statement expression)</p></li><li class="list__item" id="459424c6_2241"><p>for-init-statement</p></li><li class="list__item" id="459424c6_2242"><p>顺序</p></li><li class="list__item" id="459424c6_2243"><p>C+＋确保程序从左向右进行计算逻辑表达式，并在知道答案后立刻停止</p></li><li class="list__item" id="459424c6_2244"><p>静态类型检查</p></li><li class="list__item" id="459424c6_2245"><p>仅当只有一层间接关系时，才可以将非const地址或指针赋给const指针</p></li><li class="list__item" id="459424c6_2246"><p>容忍逻辑上无法自圆其说的观点正是人类思维活动的特点</p></li><li class="list__item" id="459424c6_2247"><p>自动推断只能用于单值初始化，不能用于初始化列表</p></li><li class="list__item" id="459424c6_2248"><p>引用更接近const指针</p></li><li class="list__item" id="459424c6_2249"><p>常量引用</p></li><li class="list__item" id="459424c6_2250"><p>零时变量会使函数在可处理的参数种类方面更加通用，其行为类似按值传递</p></li><li class="list__item" id="459424c6_2251"><p>将引用参数声明为常量数据的引用理由有三个:使用const可以避免无意中修改数据; 使函数可以处理const和非const实参;使函数可以正确生成使用临时变量。</p></li><li class="list__item" id="459424c6_2252"><p>右值引用</p></li><li class="list__item" id="459424c6_2253"><p>模糊特性增加了犯错的机会</p></li><li class="list__item" id="459424c6_2254"><p>内置数据类型用指针，类用引用</p></li><li class="list__item" id="459424c6_2255"><p>C强调速度，CPP强调稳定性</p></li><li class="list__item" id="459424c6_2256"><p>&ldquo;多态&rdquo;指有多种形式</p></li><li class="list__item" id="459424c6_2257"><p>模板特性有时也被称为参数化类型</p></li><li class="list__item" id="459424c6_2258"><p>编译器在选择原型时，非模板版本优先于显式具体化，显式具体化优先于模板版本</p></li><li class="list__item" id="459424c6_2259"><p>函数模板只是一个用于生成函数定义的方案</p></li><li class="list__item" id="459424c6_2260"><p>模板并非函数定义，模板实例是函数定义</p></li><li class="list__item" id="459424c6_2261"><p>隐式实例化、显式实例化、显式具体化统称为具体化</p></li><li class="list__item" id="459424c6_2262"><p>显式实例化遇到引用可能会出问题</p></li><li class="list__item" id="459424c6_2263"><p>重载解析</p></li><li class="list__item" id="459424c6_2264"><p>最具体并不意味着显式具体化</p></li><li class="list__item" id="459424c6_2265"><p>&ldquo;最具体&rdquo;</p></li><li class="list__item" id="459424c6_2266"><p>C11后置返回类型</p></li><li class="list__item" id="459424c6_2267"><p>存储持续性，作用域和链接</p></li><li class="list__item" id="459424c6_2268"><p>头文件：包含结构声明和使用这些结构的函数原型</p></li><li class="list__item" id="459424c6_2269"><p>源代码文件：包含与结构相关的函数的代码</p></li><li class="list__item" id="459424c6_2270"><p>源代码文件：包含调用与结构相关的函数的代码</p></li><li class="list__item" id="459424c6_2271"><p>翻译单元</p></li><li class="list__item" id="459424c6_2272"><p>自动存储持续性（auto/register）</p></li><li class="list__item" id="459424c6_2273"><p>静态存储持续性（static/全局）</p></li><li class="list__item" id="459424c6_2274"><p>线程存储持续性（C++11）</p></li><li class="list__item" id="459424c6_2275"><p>动态存储持续性（堆）</p></li><li class="list__item" id="459424c6_2276"><p>链接性决定了哪些信息可在文件间共享</p></li><li class="list__item" id="459424c6_2277"><figure id="459424c6_2278"><img alt="stack" src="images/stack.png" title="stack" width="1018" height="1212"></figure></li><li class="list__item" id="459424c6_2279"><p>静态变量都先执行零初始化后覆盖</p></li><li class="list__item" id="459424c6_2280"><p>关键字重载</p></li><li class="list__item" id="459424c6_2281"><p>存储说明符/cv-限定符</p></li><li class="list__item" id="459424c6_2282"><p>通常编译器使用三块独立的内存：一块用于静态变量，一块用于自动变量，一块用于动态存储</p></li><li class="list__item" id="459424c6_2283"><p>您可能想知道定位new 运算符的工作原理。基本上，它只是返回传递给它的地址，并将其强制转换 为void* ，以便能够赋给任何指针类型。但这说的是默认定位new 函数， C++允许程序员重载定位new函数</p></li><li class="list__item" id="459424c6_2284"><p>名称可以是变量、函数、结构、枚举、类以及类和结构的成员</p></li><li class="list__item" id="459424c6_2285"><p>声明区域(declaration region)</p></li><li class="list__item" id="459424c6_2286"><p>潜在作用域(potential scope )</p></li><li class="list__item" id="459424c6_2287"><figure id="459424c6_2288"><img alt="作用域.png" src="images/%E4%BD%9C%E7%94%A8%E5%9F%9F.png" title="作用域.png" width="1075" height="2144"></figure></li><li class="list__item" id="459424c6_2289"><p>在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。</p></li><li class="list__item" id="459424c6_2290"><p>全局名称空间(global namespace)</p></li><li class="list__item" id="459424c6_2291"><figure id="459424c6_2292"><img alt="namespace.png" src="images/namespace.png" title="namespace.png" width="1971" height="831"></figure></li><li class="list__item" id="459424c6_2293"><p>生活中充满复杂性，处理复杂性的方法之一是简化和抽象</p></li><li class="list__item" id="459424c6_2294"><p>在C丑中，用户定义类型指的是实现抽象接口的类设计</p></li><li class="list__item" id="459424c6_2295"><p>数据隐藏不仅可以防止直接访问数据，还让开发者（类的用户）无需了解数据是如何被表示的</p></li><li class="list__item" id="459424c6_2296"><p>使用私有成员函数来处理不属于公有接 口的实现细节</p></li><li class="list__item" id="459424c6_2297"><p>定义位于类声明中的函数都将自动成为内联函数</p></li><li class="list__item" id="459424c6_2298"><p>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义</p></li><li class="list__item" id="459424c6_2299"><p>根据改写规则(rewrite rule ) ，在类声明中定义方法等同于用原型替换方法定义，然后在类声明的后面将定义改写为内联函数</p></li><li class="list__item" id="459424c6_2300"><p>隐式地调用默认构造函数时，不要使用圆括号</p></li><li class="list__item" id="459424c6_2301"><p>默认构造函数可以没有任何参数；如果有，则必须给所有参数都提供默认值</p></li><li class="list__item" id="459424c6_2302"><p>第一条语句是初始化，它创建有指定值的对象，可能会创建临时对象（也可能不会）；第二条语句是赋值。像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象。</p></li><li class="list__item" id="459424c6_2303"><p>初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有默认构造函数。</p></li><li class="list__item" id="459424c6_2304"><p>作用域内枚举（C++11）</p></li><li class="list__item" id="459424c6_2305"><p>ADT 以通用的方式描述数据类型，而没有引入语言或实现细节</p></li><li class="list__item" id="459424c6_2306"><p>只有类声明可以决定哪一个函数是友元，因此类声明仍然控制了哪些函数可以访问私有数据</p></li><li class="list__item" id="459424c6_2307"><p>状态成员(state member)</p></li><li class="list__item" id="459424c6_2308"><p>如果方法通过计算得到一个新的类对象，则应考虑是否可以使用类构造函数来完成这种工作。 这样做不仅可以避免麻烦，而且可以确保新的对象是按照正确的方式创建的</p></li><li class="list__item" id="459424c6_2309"><p>将接口与实现分离是OOP 的目标之一，这样允许对实现进行调整，而无需修改使用这个类的程序中的代码</p></li><li class="list__item" id="459424c6_2310"><p>因为所有的Vector 类方法的作用域都为整个类，所以导入类名后，无需提供其他using 声明，就可以使用Vector 的方法。</p></li><li class="list__item" id="459424c6_2311"><p>只接受一个参数的构造函数定义了从参数类型到类类型的转换。如果使用关键字explicit 限定了这种构造函数， 则它只能用于显示转换， 否则也可以用于隐式转换。</p></li><li class="list__item" id="459424c6_2312"><p>友元函数与成员函数之间的区别是什么？</p></li><li class="list__item" id="459424c6_2313"><p>不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。</p></li><li class="list__item" id="459424c6_2314"><p>对于不能在类声明中初始化静态数据成员的一种例外情况是，静态数据成员为整型或枚举型const</p></li><li class="list__item" id="459424c6_2315"><p>按值传递意味着创建原始变量的一个副本</p></li><li class="list__item" id="459424c6_2316"><p>默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值</p></li><li class="list__item" id="459424c6_2317"><p>如果类中包含了使用new 初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。复制的另一种形式（ 成员复制或浅复制）只是复制指针值。浅复制仅浅浅地复制指针信息，而不会深入＂挖掘&ldquo;以复制指针引用的结构。</p></li><li class="list__item" id="459424c6_2318"><p>初始化总是会调用复制构造函数，而使用式运算符时也可能调用赋值运算符</p></li><li class="list__item" id="459424c6_2319"><p>赋值运算符有两个责任：妥善删除旧的数据、赋得新的数据</p></li></ul><div class="last-modified">Last modified: 29 一月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="速查表.html" class="navigation-links__prev">速查表</a><a href="the-philosophy.html" class="navigation-links__next">The Philosophy</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>