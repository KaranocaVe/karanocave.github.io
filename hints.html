<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2024-01-24T12:26:19.440903"><meta name="build-number" content="${buildNumber}">       <title>hints | KaranocaVe's Blog</title><script id="virtual-toc-data" type="application/json">[]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="hints | KaranocaVe's Blog"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="KaranocaVe's Blog Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="karanocave.infohints.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="hints | KaranocaVe's Blog"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "karanocave.infohints.html#webpage", "url": "karanocave.infohints.html", "name": "hints | KaranocaVe's Blog", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "karanocave.info/#website", "url": "karanocave.info/", "name": "KaranocaVe's Blog Help" }</script><!-- End Schema.org --></head>      <body data-id="hints" data-main-title="hints" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="worldview.md|世界观///The-Cpp-Programing-Language.md|The C++ Programing Language"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>KaranocaVe's Blog  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="hints"   id="hints.md">hints</h1>  <ul class="list _ul" id="999ec0ac_1556"><li class="list__item" id="999ec0ac_1557"><p>宽度</p></li><li class="list__item" id="999ec0ac_1558"><p>初始化器</p></li><li class="list__item" id="999ec0ac_1559"><p>自然长度</p></li><li class="list__item" id="999ec0ac_1560"><p>源字符集 执行字符集</p></li><li class="list__item" id="999ec0ac_1561"><p>通用字符名</p></li><li class="list__item" id="999ec0ac_1562"><p>算术类型</p></li><li class="list__item" id="999ec0ac_1563"><p>任何值或任何有效的值和运算符的组合都是表达式</p></li><li class="list__item" id="999ec0ac_1564"><p>＜＜运算符的优先级比表达式中使用的运算符高</p></li><li class="list__item" id="999ec0ac_1565"><p>声明语句表达式(declaration-statement expression)</p></li><li class="list__item" id="999ec0ac_1566"><p>for-init-statement</p></li><li class="list__item" id="999ec0ac_1567"><p>顺序</p></li><li class="list__item" id="999ec0ac_1568"><p>C+＋确保程序从左向右进行计算逻辑表达式，并在知道答案后立刻停止</p></li><li class="list__item" id="999ec0ac_1569"><p>静态类型检查</p></li><li class="list__item" id="999ec0ac_1570"><p>仅当只有一层间接关系时，才可以将非const地址或指针赋给const指针</p></li><li class="list__item" id="999ec0ac_1571"><p>容忍逻辑上无法自圆其说的观点正是人类思维活动的特点</p></li><li class="list__item" id="999ec0ac_1572"><p>自动推断只能用于单值初始化，不能用于初始化列表</p></li><li class="list__item" id="999ec0ac_1573"><p>引用更接近const指针</p></li><li class="list__item" id="999ec0ac_1574"><p>常量引用</p></li><li class="list__item" id="999ec0ac_1575"><p>零时变量会使函数在可处理的参数种类方面更加通用，其行为类似按值传递</p></li><li class="list__item" id="999ec0ac_1576"><p>将引用参数声明为常量数据的引用理由有三个:使用const可以避免无意中修改数据; 使函数可以处理const和非const实参;使函数可以正确生成使用临时变量。</p></li><li class="list__item" id="999ec0ac_1577"><p>右值引用</p></li><li class="list__item" id="999ec0ac_1578"><p>模糊特性增加了犯错的机会</p></li><li class="list__item" id="999ec0ac_1579"><p>内置数据类型用指针，类用引用</p></li><li class="list__item" id="999ec0ac_1580"><p>C强调速度，CPP强调稳定性</p></li><li class="list__item" id="999ec0ac_1581"><p>&ldquo;多态&rdquo;指有多种形式</p></li><li class="list__item" id="999ec0ac_1582"><p>模板特性有时也被称为参数化类型</p></li><li class="list__item" id="999ec0ac_1583"><p>编译器在选择原型时，非模板版本优先于显式具体化，显式具体化优先于模板版本</p></li><li class="list__item" id="999ec0ac_1584"><p>函数模板只是一个用于生成函数定义的方案</p></li><li class="list__item" id="999ec0ac_1585"><p>模板并非函数定义，模板实例是函数定义</p></li><li class="list__item" id="999ec0ac_1586"><p>隐式实例化、显式实例化、显式具体化统称为具体化</p></li><li class="list__item" id="999ec0ac_1587"><p>显式实例化遇到引用可能会出问题</p></li><li class="list__item" id="999ec0ac_1588"><p>重载解析</p></li><li class="list__item" id="999ec0ac_1589"><p>最具体并不意味着显式具体化</p></li><li class="list__item" id="999ec0ac_1590"><p>&ldquo;最具体&rdquo;</p></li><li class="list__item" id="999ec0ac_1591"><p>C11后置返回类型</p></li><li class="list__item" id="999ec0ac_1592"><p>存储持续性，作用域和链接</p></li><li class="list__item" id="999ec0ac_1593"><p>头文件：包含结构声明和使用这些结构的函数原型</p></li><li class="list__item" id="999ec0ac_1594"><p>源代码文件：包含与结构相关的函数的代码</p></li><li class="list__item" id="999ec0ac_1595"><p>源代码文件：包含调用与结构相关的函数的代码</p></li><li class="list__item" id="999ec0ac_1596"><p>翻译单元</p></li><li class="list__item" id="999ec0ac_1597"><p>自动存储持续性（auto/register）</p></li><li class="list__item" id="999ec0ac_1598"><p>静态存储持续性（static/全局）</p></li><li class="list__item" id="999ec0ac_1599"><p>线程存储持续性（C++11）</p></li><li class="list__item" id="999ec0ac_1600"><p>动态存储持续性（堆）</p></li><li class="list__item" id="999ec0ac_1601"><p>链接性决定了哪些信息可在文件间共享</p></li><li class="list__item" id="999ec0ac_1602"><figure  id="999ec0ac_1603"><img alt="stack" src="images/stack.png" title="stack"  width="1018" height="1212"></figure></li><li class="list__item" id="999ec0ac_1604"><p>静态变量都先执行零初始化后覆盖</p></li><li class="list__item" id="999ec0ac_1605"><p>关键字重载</p></li><li class="list__item" id="999ec0ac_1606"><p>存储说明符/cv-限定符</p></li><li class="list__item" id="999ec0ac_1607"><p>通常编译器使用三块独立的内存：一块用于静态变量，一块用于自动变量，一块用于动态存储</p></li><li class="list__item" id="999ec0ac_1608"><p>您可能想知道定位new 运算符的工作原理。基本上，它只是返回传递给它的地址，并将其强制转换 为void* ，以便能够赋给任何指针类型。但这说的是默认定位new 函数， C++允许程序员重载定位new函数</p></li><li class="list__item" id="999ec0ac_1609"><p>名称可以是变量、函数、结构、枚举、类以及类和结构的成员</p></li><li class="list__item" id="999ec0ac_1610"><p>声明区域(declaration region)</p></li><li class="list__item" id="999ec0ac_1611"><p>潜在作用域(potential scope )</p></li><li class="list__item" id="999ec0ac_1612"><figure  id="999ec0ac_1613"><img alt="作用域.png" src="images/%E4%BD%9C%E7%94%A8%E5%9F%9F.png" title="作用域.png"  width="1075" height="2144"></figure></li><li class="list__item" id="999ec0ac_1614"><p>在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。</p></li><li class="list__item" id="999ec0ac_1615"><p>全局名称空间(global namespace)</p></li><li class="list__item" id="999ec0ac_1616"><figure  id="999ec0ac_1617"><img alt="namespace.png" src="images/namespace.png" title="namespace.png"  width="1971" height="831"></figure></li><li class="list__item" id="999ec0ac_1618"><p>生活中充满复杂性，处理复杂性的方法之一是简化和抽象</p></li><li class="list__item" id="999ec0ac_1619"><p>在C丑中，用户定义类型指的是实现抽象接口的类设计</p></li><li class="list__item" id="999ec0ac_1620"><p>数据隐藏不仅可以防止直接访问数据，还让开发者（类的用户）无需了解数据是如何被表示的</p></li><li class="list__item" id="999ec0ac_1621"><p>使用私有成员函数来处理不属于公有接 口的实现细节</p></li><li class="list__item" id="999ec0ac_1622"><p>定义位于类声明中的函数都将自动成为内联函数</p></li><li class="list__item" id="999ec0ac_1623"><p>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义</p></li><li class="list__item" id="999ec0ac_1624"><p>根据改写规则(rewrite rule ) ，在类声明中定义方法等同于用原型替换方法定义，然后在类声明的后面将定义改写为内联函数</p></li><li class="list__item" id="999ec0ac_1625"><p>隐式地调用默认构造函数时，不要使用圆括号</p></li><li class="list__item" id="999ec0ac_1626"><p>默认构造函数可以没有任何参数；如果有，则必须给所有参数都提供默认值</p></li><li class="list__item" id="999ec0ac_1627"><p>第一条语句是初始化，它创建有指定值的对象，可能会创建临时对象（也可能不会）；第二条语句是赋值。像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象。</p></li><li class="list__item" id="999ec0ac_1628"><p>初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有默认构造函数。</p></li><li class="list__item" id="999ec0ac_1629"><p>作用域内枚举（C++11）</p></li><li class="list__item" id="999ec0ac_1630"><p>ADT 以通用的方式描述数据类型，而没有引入语言或实现细节</p></li></ul><div class="last-modified"> Last modified: 24 一月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="速查表.html">速查表</a>   <a class="navigation-links__next" href="the-philosophy.html">The Philosophy</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>